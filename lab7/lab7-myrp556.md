#LAB7 Report

## [Ex0] 填写已有实验

## [Ex1] 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题(不需要编码)
	完成练习0后,建议大家比较一下(可用kdiff3等文件比较软件)个人完成的lab6和练习0完成后的刚修改的lab7之间的区别,
	分析了解lab7采用信号量的执行过程。执行make	grade,大部分测试用例应该通过。
### 请在实验报告中给出内核级信号量的设计描述,并说其大致执行流流程。
```
内核信号semaphore_t实现是通过计数来完成的。这个信号量内部有一个计数值，表示当前临界区可以申请访问的数量。
当这个计数值<=0，就会使申请访问的函数处于等待状态，等待有其他进程释放的时候，这个计数值就会增加，使得其他进程可以访问临界区。

执行流程：
	up()函数：关中断->如果wait_queue为空,计数值+1，开中断返回，否则就等待
	down()函数：关中断->如果计数值>0,则计数值-1，开中断返回，否则进入到等待队列，开中断切换进程。如果被up()函数唤醒则关中断从等待队列中移除在开中断。
```
### 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同

```
都实现了信号量。基本内容实现与在内核态中相似。在实现用户态的信号量中，在内核态也构建了一个信号量。同时两者相互关联，使用内核提供的函数接口可以使得用户态可以调用同步内核态的信号量。

相同：都是类似的同步互斥的操作
不同：用户态不能够直接修改操作内核态
```

## [Ex2]: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）

```
判断count计数值
	>0:
		唤醒进程
		自身休眠
		next_count+1
		当改进程被唤醒：
			next_count-1
	否则返回

cond_wait():
	count+1
	根据next_count计数进行唤醒操作或者释放mutex
	自身睡眠
	当自身由于另一个进程的signal而被唤醒时
	继续执行
	被唤醒后
	count-1
	
phi_take_forks_condvar函数：
	设置相应哲学家状态为HUNGERY
	调用phi_test_condvar()判断是否可以进餐
	如果该哲学家的状态不是EATING，则该哲学家现在不能就餐，让其进入等待
	
phi_put_forks_condvar函数：
	将该哲学家的状态更改为THINKING
	调用phi_test_condvar()函数分别检测其左边和右边能否就餐

与标准答案的不同:
	根据注释提示的结果，因此基本一致

```

### 请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程

```
管程的定义如下：
	typedef struct monitor{
		semaphore_t mutex;
		semaphore_t next;
		int next_count;
		condvar_t *cv;
	} monitor_t;
其中mutex是互斥锁。保证每次只能让一个进程访问这个管程。

管程的数据结构在ucore_lab中定义为monitor_t，其组成结构如下所示：

typedef struct monitor{
    semaphore_t mutex;
    semaphore_t next;
    int next_count;
    condvar_t *cv;
} monitor_t;
下面介绍一下其中的变量的意义：
mutex保证每一次只允许一个进程进入管程。
在一个进程进入signal_cv的时候，需要使其他进程进入休眠，在这个进程离开需要唤醒其他进程的时候next_count记录了进入signal_cv需要进入休眠的进程的个数。

条件变量：
typedef struct condvar{
    semaphore_t sem;
    int count;
    monitor_t * owner;
} condvar_t;
其中sem是信号量，能实现让发出wait_cv且等待某个条件为真的进程处于睡眠状态，让发出signal_cv操作的进程通过它唤醒睡眠的进程。
count表示等待休眠进程的数量
owner表示从属的管程

其中cond_wait()函数实现了wait_cv的操作，cond_signal函数实现了signal_cv的操作
```

### 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。

```
建立一个用户态的数据结构，与内核态条件变量对应，建立该数据结构的一个实体的时候需要同时在内核态生成一个对应的
变量，建立二者的映射关系并存储、关联二者的进程。需要建立一些接口函数对应于初始化、wait操作和signal操作的系统
调用，便于用户态程序操作内核态的条件变量。

一个用户态的条件变量在内核态也会构建一个对应的变量，两个变量相互关联。之后建立映射，存储关系，初始化一些操作，使得用户态能够使用并调用到内核态的条件变量。

相同：都是实现的同步互斥操作
不同：用户态不能直接操作条件变量，需要通过调用内核态的接口。
```

## 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点
```
管程，互斥锁，信号量，条件变量。
消费者问题
哲学家就餐问题
```

## 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
```
原子操作，消费者问题，死锁，饥饿
```


